# Лабораторная работа lab5var9  
**Вариант 9**

Проект оформлен **в одном проекте**, но **в разных классах** (в нашем случае — два файла: `Lab5Var9.java` с классами и `Main5Var9.java` с единственным `main`).  
В `main` показана работа **всех задач** с дружественным интерфейсом.  
Все исходные данные вводятся **с клавиатуры**, реализована **проверка ввода**.  
Во всех классах присутствуют **поля**, **конструкторы** и **`toString()`**.

---

## Файлы проекта

- `Lab5Var9.java` — все сущности и методы задач (логика)
- `Main5Var9.java` — единственная точка входа, демонстрация всех задач

---

## Задание 1  
**Шаблоны — №1: Дробь (интерфейс + кэширование)**

### Условие
1. Создать интерфейс для сущности **Дробь**, содержащий методы:
   - получение вещественного значения
   - установка числителя
   - установка знаменателя
2. Создать обычную дробь (если ранее её не было) и реализовать этот интерфейс.
3. Создать версию дроби, которая **кэширует вычисление вещественного значения**.
4. Продемонстрировать работу кэширования:
   - при повторном вызове `toDouble()` значение берётся из кэша
   - при изменении числителя/знаменателя кэш сбрасывается

### Алгоритм решения
1. Создан интерфейс `FractionOps` (`toDouble`, `setNumerator`, `setDenominator`).
2. Класс `Fraction` хранит `numerator/denominator`, проверяет знаменатель на `0`, нормализует знак.
3. Класс `CachedFraction` наследуется от `Fraction` и хранит:
   - `cacheValid` — актуален ли кэш
   - `cacheValue` — сохранённое значение
4. В `toDouble()`:
   - если кэш неактуален — вычисляем и сохраняем
   - иначе возвращаем сохранённое
5. В `setNumerator/setDenominator` кэш сбрасывается.

### Демонстрация
В `Main5Var9`:
- вводится дробь
- `toDouble()` вызывается дважды (второй раз — из кэша)
- меняется числитель и снова вызывается `toDouble()` (кэш пересчитывается)

---

## Задание 2  
**Структурные шаблоны — №1: Количество мяуканий**

### Условие
Имеется класс **Кот** и метод, который заставляет котов мяукать.  
Нужно посчитать **сколько раз кот мяукнул**, при этом **изменять класс Кот нельзя**.

### Алгоритм решения
1. Создан интерфейс `Meowable` с методом `meow()`.
2. `Cat` реализует `Meowable` и просто выводит `"имя: мяу!"`.
3. Создан декоратор `MeowCounter`, который:
   - хранит ссылку на `Meowable`
   - увеличивает счётчик при каждом `meow()`
   - затем вызывает `meow()` у исходного объекта
4. В метод `meowsCare(...)` передаётся **обёрнутый** объект `MeowCounter`.

### Демонстрация
В `Main5Var9`:
- вводится имя кота и количество мяуканий
- кот мяукает через `MeowCounter`
- выводится итоговый счётчик

---

## Задание 3  
**Список — №8: L = элементы L1, которых нет в L2 (по одному разу)**

### Условие
Сформировать список `L`, включив в него **по одному разу** элементы, которые:
- входят в `L1`
- **не** входят в `L2`

### Алгоритм решения
1. Проходим по `L1`.
2. Если элемент не содержится в `L2` — добавляем в результат.
3. Чтобы добавить **по одному разу** и сохранить порядок, используем `LinkedHashSet`.
4. В конце возвращаем `ArrayList` из множества.

### Демонстрация
В `Main5Var9`:
- вводятся `L1` и `L2`
- выводится итоговый список `L`

---

## Задание 4  
**Map — №9: школы выше среднего по району (данные из файла)**

### Условие
В текстовом файле записано:
- число `N`
- затем `N` строк вида: `Фамилия Имя Школа Балл`

Нужно вывести **номера школ**, у которых **средний балл выше среднего по району**.

### Алгоритм решения
1. Считываем файл.
2. Считаем общий средний балл по району:
   - `totalSum / totalCount`
3. Параллельно копим статистику по школам в `Map<school, [sum, count]>`.
4. Для каждой школы считаем средний балл и сравниваем со средним по району.
5. Номера подходящих школ сортируем и выводим.

### Демонстрация
В `Main5Var9`:
- вводится путь к файлу
- выводятся номера школ, подходящих по условию

---

## Задание 5  
**Set — №10: символы, встречающиеся ровно в одном слове (данные из файла)**

### Условие
В текстовом файле дан текст.  
Нужно найти символы, которые встречаются **в одном и только в одном слове**.

### Алгоритм решения
1. Считываем текст из файла.
2. Разбиваем текст на слова (последовательности букв/цифр).
3. Для каждого слова строим множество символов `Set<Character>` — чтобы один символ в слове считался один раз.
4. В `Map<Character, Integer>` считаем, в скольких словах встречался символ.
5. Оставляем символы, где счётчик равен `1`, сортируем и выводим.

### Демонстрация
В `Main5Var9`:
- вводится путь к текстовому файлу
- выводится список подходящих символов

---

## Задание 6  
**Очередь — №5: переписать L1 в L2 в обратном порядке**

### Условие
Переписать элементы из очереди `L1` в очередь `L2` **в обратном порядке**.

### Алгоритм решения
1. Извлекаем элементы из `L1` и кладём в стек (`Deque.push`).
2. Затем извлекаем из стека и кладём в `L2`.
3. В результате:
   - `L1` становится пустой
   - `L2` содержит элементы в обратном порядке

### Демонстрация
В `Main5Var9`:
- вводится очередь `L1`
- выводятся `L1` (пустая) и `L2` (обратный порядок)

---

## Задание 7.1  
**Stream — №1: из Point собрать Polyline**

### Условие
Из набора `Point` нужно:
1. оставить точки только в **разных координатах**
2. отсортировать по `X`
3. отрицательные `Y` сделать положительными
4. собрать результат в `Polyline`

### Алгоритм решения
1. `distinct()` — удаление дублей по координатам (`equals/hashCode` в `Point`).
2. `sorted(Comparator.comparingDouble(Point::getX))` — сортировка по X.
3. `map(p -> new Point(p.getX(), abs(p.getY())))` — исправление Y.
4. `collect` в список и создание `Polyline`.

### Демонстрация
В `Main5Var9`:
- вводятся точки
- выводится полученная `Polyline`

---

## Задание 7.2  
**Stream — №2: группировка имён по номеру (из файла)**

### Условие
В файле строки вида:
- `Вася:5`
- `Петя:3`
- `Миша:` (без номера)

Требуется:
1. Нормализовать имена: lowerCase + первая буква UpperCase
2. Удалить записи без номера
3. Сгруппировать в `Map<номер, List<имён>>`

### Алгоритм решения
1. Читаем строки из файла.
2. Парсим `Имя:номер` (если номера нет — пропускаем).
3. Нормализуем имя.
4. Добавляем имя в список по ключу `номер` в `Map`.

### Демонстрация
В `Main5Var9`:
- вводится путь к файлу
- выводится итоговая карта группировки

---
